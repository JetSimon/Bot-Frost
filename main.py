#!/usr/bin/env python3.7
import discord
import requests
from discord.ext import commands
from discord.utils import get
from bs4 import BeautifulSoup
from cogs.betting_commands import store_next_opponent
from cogs.reddit_commands import reddit_footer, reddit_reactions, vote_post
import sys
import config
import random
import re
import cogs.croot_bot
import datetime
import json
import hashlib
import time
import mysql
import asyncio
from config import client

# Cogs
client.load_extension('cogs.image_commands')
client.load_extension('cogs.text_commands')
client.load_extension('cogs.croot_bot')
# client.load_extension('cogs.bg_croot_bot')
client.load_extension('cogs.stat_bot')
client.load_extension('cogs.sched_commands')
client.load_extension('cogs.betting_commands')
client.load_extension('cogs.reddit_commands')
client.load_extension('cogs.games.hangman')
client.load_extension('cogs.games.trivia')

# initialize a global list for CrootBot to put search results in
welcome_emoji_list = ['🔴', '🍞', '🥔', '🥒', '😂']
emoji_list = ['1⃣', '2⃣', '3⃣', '4⃣', '5⃣', '6⃣', '7⃣', '8⃣', '9⃣', '🔟']
bet_emojis = ["⬆", "⬇", "❎", "⏫", "⏬", "❌", "🔼", "🔽", "✖"]
arrows = ("⬆", "⬇", "↔")
huskerbot_footer="Generated by HuskerBot"
welcome_footer='HusekrBot welcomes you!'
wrong_channel_text='The command you sent is not authorized for use in this channel.'

profile_url = None
highlight_url = None


def try_adding_new_dict(bet_username: str, which: str, placed_bet):
    if which == "winorlose":
        with mysql.sqlConnection.cursor() as cursor:
            cursor.execute(config.sqlInsertWinorlose, (config.current_game[2], bet_username, int(placed_bet), int(placed_bet)))
        mysql.sqlConnection.commit()

    elif which == "canx_winorlose":
        with mysql.sqlConnection.cursor() as cursor:
            cursor.execute(config.sqlInsertWinorlose, (config.current_game[2], bet_username, -1, -1))
        mysql.sqlConnection.commit()

    elif which == "spread":
        with mysql.sqlConnection.cursor() as cursor:
            cursor.execute(config.sqlInsertSpread, (config.current_game[2], bet_username, placed_bet, placed_bet))
        mysql.sqlConnection.commit()
    elif which == "canx_spread":
        with mysql.sqlConnection.cursor() as cursor:
            cursor.execute(config.sqlInsertSpread, (config.current_game[2], bet_username, -1, -1))
        mysql.sqlConnection.commit()

    elif which == "moneyline":
        with mysql.sqlConnection.cursor() as cursor:
            cursor.execute(config.sqlInsertMoneyline, (config.current_game[2], bet_username, placed_bet, placed_bet))
        mysql.sqlConnection.commit()
    elif which == "canx_moneyline":
        with mysql.sqlConnection.cursor() as cursor:
            cursor.execute(config.sqlInsertMoneyline, (config.current_game[2], bet_username, -1, -1))
        mysql.sqlConnection.commit()


def server_member_count():
    return len(client.users)


async def pinned_board(reactions: list):
    chan = client.get_channel(id=487431877792104470)

    if chan is None:
        chan = client.get_channel(id=616824929383612427)

    banned_channels = (525519594417291284, 538419127535271946, 458474143403212801)

    if chan.id in banned_channels:
        return

    pinned_messages = []
    message_history_raw = []
    duplicate = False

    threshold = int(0.0075 * server_member_count())

    for reaction in reactions:
        if reaction.count >= threshold and not reaction.message.channel.name == chan.name and not ".addvotes" in reaction.message.content:
            if not reaction.message.author.bot:
                message_history_raw = await chan.history(limit=5000).flatten()

                for message_raw in message_history_raw:
                    if len(message_raw.embeds) > 0:
                        if message_raw.embeds[0].footer.text == str(reaction.message.id):
                            duplicate = True
                            break

                if not duplicate:
                    embed = discord.Embed(title=f"🏆 Husker Discord Hall of Fame Message by {reaction.message.author} with the {reaction} reaction 🏆", color=0xFF0000)
                    embed.add_field(name=f"Author: {reaction.message.author}", value=f"{reaction.message.content}")
                    embed.set_footer(text=reaction.message.id)
                    await chan.send(embed=embed)
                # else:
                #     print(f"Duplicate found, message ID: {reaction.message.id}")

    del message_history_raw
    del pinned_messages
    del duplicate


@client.event
async def on_ready():
    nicks = ("Bot Frost", "Mario Verbotzco", "Adrian Botinez", "Bot Devaney", "Mike Rilbot", "Robo Pelini", "Devine Ozigbot", "Mo Botty", "Bot Moos")

    try:
        await client.change_presence(activity=discord.Activity(type=discord.ActivityType.watching, name="Husker football 24/7"))
        print("*** Version Information:\n"
              "    Logged in as [{}].\n"
              "    Login time: [{}]\n"
              "    Ready: [{}]\n"
              "    Discord.py version is: [{}].\n"
              "    Discord version is: [{}].".format(client.user, datetime.datetime.now(), client.is_ready(), discord.__version__, sys.version, client.owner_id))
    except asyncio.TimeoutError as e:
        print("*** Client timed out!\n"
              "*** {}\n"
              "***".format(e))
    except:
        print("*** Unknown exception happened!\n"
              "***")

    try:
        for members in client.get_all_members():
            if members.name == client.user.name:
                await members.edit(nick=random.choice(nicks))
                print("    Nickname: {}\n***".format(members.nick))
                break
    except:
        print("Nickname change didn't work lol")


@client.event
async def on_message(message):
    """ Commands processed as messages are entered """
    if not message.author.bot:
        # Add Up Votes and Down Votes
        if ".addvotes" in message.content.lower():
            for arrow in arrows:
                await message.add_reaction(arrow)

        # Link a subreddit
        #get a list of subreddits mentioned
        subreddits = re.findall(r'(?:^| )(/?r/[a-z]+)', message.content.lower())
        if len(subreddits) > 0:
            embed = discord.Embed(title="Found Subreddits")
            for s in subreddits:
                if "huskers" in s:
                    break
                elif "cfb" in s:
                    break

                url='https://reddit.com/' + s
                if '.com//r/' in url:
                    url = url.replace('.com//r', '.com/r')
                embed.add_field(name = s, value = url, inline = False)
                await message.channel.send(embed = embed)

        # Good bot, bad bot
        if "good bot" in message.content.lower():
            await message.channel.send("OwO thanks")
        elif "bad bot" in message.content.lower():
            embed = discord.Embed(title="I'm a bad, bad bot")
            embed.set_image(url='https://i.imgur.com/qDuOctd.gif')
            await message.channel.send(embed=embed)
        elif "fuck you bot" in message.content.lower() or "you suck bot" in message.content.lower():
            myass = ["https://66.media.tumblr.com/b9a4c96d0c83bace5e3ff303abc08f1f/tumblr_oywc87sfsP1w8f7y5o3_500.gif", "https://66.media.tumblr.com/2ae73f93fcc20311b00044abc5bad05f/tumblr_oywc87sfsP1w8f7y5o1_500.gif", "https://66.media.tumblr.com/102d761d769840a541443da82e0b211a/tumblr_oywc87sfsP1w8f7y5o5_500.gif", "https://66.media.tumblr.com/252fd1a689f0f64cb466b4eced502af7/tumblr_oywc87sfsP1w8f7y5o2_500.gif", "https://66.media.tumblr.com/83eb614389b1621be0ce9890b1998644/tumblr_oywc87sfsP1w8f7y5o4_500.gif", "https://66.media.tumblr.com/f833da26820867601cd7ad3a7c2d96a5/tumblr_oywc87sfsP1w8f7y5o6_500.gif", "https://66.media.tumblr.com/tumblr_m7e2ahFFDo1qcuoflo1_250.gif", "https://66.media.tumblr.com/tumblr_m7e2ahFFDo1qcuoflo2_250.gif", "https://66.media.tumblr.com/tumblr_m7e2ahFFDo1qcuoflo3_250.gif", "https://66.media.tumblr.com/tumblr_m7e2ahFFDo1qcuoflo4_250.gif", "https://66.media.tumblr.com/tumblr_m7e2ahFFDo1qcuoflo6_250.gif"]
            random.shuffle(myass)
            embed = discord.Embed(title="Excuse me..", color=0xFF0000)
            embed.set_image(url=myass[0])
            await message.channel.send(embed=embed, content=message.author.mention)
        elif "love you bot" in message.content.lower() or "love u bot" in message.content.lower() or "luv u bot" in message.content.lower() or "luv you bot" in message.content.lower():
            embed = discord.Embed(title="Shut Up Baby, I Know It")
            embed.set_image(url="https://media1.tenor.com/images/c1fd95af4433edf940fdc8d08b411622/tenor.gif?itemid=7506108")
            await message.channel.send(embed=embed)

        # Husker Bot hates Isms
        if "isms" in message.content.lower():
            dice_roll = random.randint(1,101)
            if dice_roll >= 90:
                await message.channel.send("Isms? That no talent having, no connection having hack? All he did was lie and "
                                           "make **shit** up for fake internet points. I'm glad he's gone.")

        notavirus = "NotaVirus_Click#3411"
        if str(message.author).lower() == notavirus.lower():
            dice_roll = random.randint(1, 101)
            if dice_roll > 65:
                if "you suck" in message.content.lower():
                    await message.channel.send("HEY NOW! I am on to you {}...".format(message.author.mention))
                elif "eggplant" in message.content.lower():
                    await message.channel.send("Attention: {} loves eggplant.".format(message.author.mention))
                elif "🍆" in message.content:
                    await message.channel.send("🍆💦")

    # Check for HuskerBot embedded messages.
    if len(message.embeds) > 0:
        # Welcome message detection. Adds reactions to message to allow user to self-assign "fun roles."
        if message.author == client.user and message.embeds[0].footer.text == welcome_footer:
            i = 0
            while i < len(welcome_emoji_list):
                await message.add_reaction(welcome_emoji_list[i])
                i += 1

        # CrootBot Search Results detection. Adds reactions to message to allow user to click to pull a search result.
        # TODO If there are multiple football players with the same name we may get the wrong guy. Especially for croots from previous classes. We will want to add more logic to narrow it down even more
        if message.author == client.user and config.player_search_list and message.embeds[0].footer.text == 'Search Results ' + huskerbot_footer:
            # Pre-add reactions for users
            i = 0
            while i < min(10, len(config.player_search_list)):
                await message.add_reaction(emoji_list[i])
                i += 1

        # $CrootBot message dection. Looks for a HUDL profile and attempts to pull a highlight video from the player's profile. Adds a reaction 🎥 to click on to show video.
        if message.author == client.user and message.embeds[0].footer.text == huskerbot_footer:
            # print("***\nChecking for highlight video")
            # global profile_url
            url = config.profile_url + 'videos' #bugging here?
            headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'}
            page = requests.get(url = url, headers = headers)
            soup = BeautifulSoup(page.text, 'html.parser')
            videos = soup.find_all(class_='title_lnk')
            if len(videos) > 0:
                # "Highlight video found")
                global highlight_url
                highlight_url = videos[0].get('href')
                if videos:
                    for v in videos:
                        if 'senior' in v.get('title').lower():
                            highlight_url = v.get('href')
                            break
                        elif 'junior' in v.get('title').lower():
                            highlight_url = v.get('href')
                            break
                        elif 'sophomore' in v.get('title').lower():
                            highlight_url = v.get('href')
                    # print("{}\n***".format(highlight_url))
                    embed_old = message.embeds[0]
                    embed_new = embed_old.set_footer(text='Click the video camera emoji to get a highlight video for this recruit')
                    await message.edit(embed=embed_new)
                    await message.add_reaction('📹')
                else:
                    print("No videos found?")
            else:
                # "No highlight video found\n***")
                pass
            config.profile_url = None

    # Always need this
    await client.process_commands(message)


@client.event
async def on_member_join(member):
    print("New member: {}".format(member.name))
    embed = discord.Embed(title="HuskerBot's Welcome Message", color=0xff0000)
    embed.add_field(name="Welcome __`{}`__ to the Huskers Discord!".format(member.name), value="The Admin team and Frost Approved members hope you have a good time while here. I am your full-serviced Discord bot, HuskerBot! You can find a list of my commands by sending `$help`.\n\n"
                   "We also have some fun roles that may interest you and you're welcome to join! The first, we have the 🔴 `@Lil' Huskers Squad`--those who are fans of Lil Red. Next up we have the 🍞 `@/r/unza` team. They are our resident Runza experts. Right behind the sandwich lovers are the 😂 `@Meme Team`! Their meme creation is second to none. Finally, we have our two food gangs: 🥔 `@POTATO GANG` and 🥒 `@Asparagang`. Which is better?\n\n"
                   "React to this message with the emojis below to automatically join the roles!", inline=False)
    embed.set_footer(text=welcome_footer)
    await member.send(embed=embed)


@client.event
async def on_raw_reaction_add(payload):

    # Putting the payload into objects and variables
    messageID = payload.message_id
    channelID = client.get_channel(payload.channel_id)
    message = await channelID.fetch_message(messageID)
    userID = payload.user_id
    user = client.get_user(userID)
    guildID = client.get_guild(payload.guild_id)
    emoji = payload.emoji.name

    await pinned_board(message.reactions)

    dbAvailable = config.pingMySQL()
    if not dbAvailable:
        await channelID.send("The MySQL database is currently unavailable. Please try again later.")
        return

    if len(message.embeds) > 0:
        # Updating season_bets JSON for reacting to a $bet message
        if emoji in bet_emojis and user != client.user and message.embeds[0].footer.text == config.bet_footer:
            if not bool(config.current_game):
                store_next_opponent(datetime.datetime.now().year)

            check_now = datetime.datetime.now()
            check_game_datetime_raw = config.current_game[1]
            check_game_datetime = datetime.datetime(day=check_game_datetime_raw.day, month=check_game_datetime_raw.month, year=check_game_datetime_raw.year, hour=check_game_datetime_raw.hour, minute=check_game_datetime_raw.minute, second=check_game_datetime_raw.second, microsecond=check_game_datetime_raw.microsecond)

            if check_now > check_game_datetime:
                await user.send("Unable to place bet because the game has started. You can review your placed bets by using `$bet show`.")
                return

            raw_username = "{}#{}".format(user.name, user.discriminator)

            formattedSpread = ""
            for field in message.embeds[0].fields:
                if str(field.name).startswith("Spread"):
                    formattedSpread = field.value
                    break

            if "Nebraska" in formattedSpread:
                underdog = True
            else:
                underdog = False

            if emoji == "⬆":
                try_adding_new_dict(raw_username, "winorlose", True)
            elif emoji == "⬇":
                try_adding_new_dict(raw_username, "winorlose", False)
            elif emoji == "❎":
                try_adding_new_dict(raw_username, "canx_winorlose", "")
            elif emoji == "⏫":
                try_adding_new_dict(raw_username, "spread", True)
            elif emoji == "⏬":
                try_adding_new_dict(raw_username, "spread", False)
            elif emoji == "❌":
                try_adding_new_dict(raw_username, "canx_spread", "")
            elif emoji == "🔼":
                try_adding_new_dict(raw_username, "moneyline", True)
            elif emoji == "🔽":
                try_adding_new_dict(raw_username, "moneyline", False)
            elif emoji == "✖":
                try_adding_new_dict(raw_username, "canx_moneyline", "")

            with mysql.sqlConnection.cursor() as cursor:
                cursor.execute(config.sqlRetrieveBet, (raw_username))
                userBetsDict = cursor.fetchall()
            mysql.sqlConnection.commit()
            cursor.close()

            for userBet in userBetsDict:
                if userBet["user"] == raw_username and userBet["game_number"] == config.current_game[2]:
                    userBetWin = "N/A"
                    userBetSpread = "N/A"
                    userBetMoneyline = "N/A"

                    if userBet["win"] == 1:
                        userBetWin = "Win"
                    elif userBet["win"] == 0:
                        userBetWin = "Lose"

                    if userBet["spread"] == 1:
                        userBetSpread = "Over"
                    elif userBet["spread"] == 0:
                        userBetSpread = "Under"

                    if userBet["moneyline"] == 1:
                        userBetMoneyline = "Over"
                    elif userBet["moneyline"] == 0:
                        userBetMoneyline = "Under"

                    userBetTime = userBet["date_updated"]

                    # Creates the embed object for all messages within method
                    embed = discord.Embed(title="Husker Game Betting", color=0xff0000)
                    embed.set_thumbnail(url="https://i.imgur.com/THeNvJm.jpg")
                    embed.set_footer(text=config.bet_footer)
                    embed.add_field(name="Author", value=raw_username, inline=False)
                    embed.add_field(name="Opponent", value=config.current_game[0].title(), inline=False)
                    embed.add_field(name="Win or Loss", value=userBetWin, inline=True)
                    embed.add_field(name="Spread", value=userBetSpread, inline=True)
                    embed.add_field(name="Over/Under Total Points", value=userBetMoneyline, inline=True)
                    embed.add_field(name="Time Placed", value=userBetTime)

                    if underdog:
                        embed.add_field(name="⚠ Warning! ⚠", value="As an underdog, Nebraska will always cover the spread if they win the game. Conversley, if Nebraska is favored and loses, they will always be unable to cover the spread.")

                    await user.send(embed=embed)
                    break

            try:
                for reaction in message.reactions:
                    if emoji == reaction.emoji:
                        await reaction.remove(user)
            except discord.Forbidden as forb:
                print("Unable to remove {}'s reaction due to Forbiddin: \n{}".format(user, forb))
            except discord.HTTPException as err:
                print("Error removing reaction from {}: {}".format(user, err))
            except:
                print("I don't know why we can't remove {}'s reaction.".format(user))

        # reddit_commands
        elif emoji in reddit_reactions and user != client.user and message.embeds[0].footer.text.startswith(reddit_footer):
            if emoji == "⬆":
                vote_post("1", message.embeds[0].footer.text.split("ID: ")[1].strip())

            elif emoji == "⬇":
                vote_post("-1", message.embeds[0].footer.text.split("ID: ")[1].strip())

        # Trivia commands
        elif user != client.user and message.embeds[0].title == "Husker Discord Trivia" and len(message.embeds[0].fields) == 2:
            import cogs.games.trivia as trivia
            from cogs.games.trivia import game
            import re

            q_search = "{}: {}".format(emoji, game.questions[game.current_question]["correct"])
            result = re.search(q_search, message.embeds[0].fields[1].value)

            if result:
                trivia.tally_score(message, user, datetime.datetime.now())
            else:
                trivia.tally_score(message, user, 0)

            for reaction in message.reactions:
                if reaction not in arrows:
                    try:
                        await reaction.remove(user)
                    except:
                        pass

    # Errything else
    else:
        if not message.author.bot and ".addvotes" in message.content and emoji not in arrows:
            for reaction in message.reactions:
                if reaction not in arrows:
                    await reaction.remove(user)
            return


@client.event
async def on_reaction_add(reaction, user):
    # await pinned_board(reaction.message.reactions)

    # Checking for an embedded message
    if len(reaction.message.embeds) > 0:
        # Checking for $CrootBot search results embedded message. Responds to added reactions by searching for and outputting a 247Sports profile for that player.
        if user != client.user and reaction.message.author == client.user and config.player_search_list and reaction.message.embeds[0].footer.text == 'Search Results ' + huskerbot_footer:
            channel = reaction.message.channel

            emoji_dict = {'1⃣': 0,
                          '2⃣': 1,
                          '3⃣': 2,
                          '4⃣': 3,
                          '5⃣': 4,
                          '6⃣': 5,
                          '7⃣': 6,
                          '8⃣': 7,
                          '9⃣': 8,
                          '🔟': 9
                          }

            if reaction.emoji in emoji_dict:
                # cb = cogs.croot_bot.CrootBot
                await cogs.croot_bot.parse_search(search=config.player_search_list[emoji_dict[reaction.emoji]], channel=channel)

        # If a 247 highlight is found for a $CrootBot response and someone reacts to the video camera, call the function to parse through the recruits hudl page and grab a highlight video
        global highlight_url
        if user != client.user and reaction.message.author == client.user and reaction.message.embeds[0].footer.text == 'Click the video camera emoji to get a highlight video for this recruit' and highlight_url is not None:
            if reaction.emoji == '📹':
                channel = reaction.message.channel
                headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'}
                url = highlight_url
                page = requests.get(url = url, headers = headers)
                soup = BeautifulSoup(page.text, 'html.parser')

                try:
                    video_url = soup.find(class_='video-wrapper').find('iframe').get('src')
                except:
                    video_url = soup.find(class_='video-container').find('iframe').get('src')
                if 'https:' not in video_url:
                    video_url='https:' + video_url   
                title = soup.find(class_='video-block').find_all('div')[2].find('h3').get_text()
                embed = discord.Embed(title = title, url = video_url, color=0xff0000)
                await channel.send(embed = embed)
                highlight_url = None

        # Checking for on_member_join() embedded message. Adds "fun role" to member based on which reaction is sent.
        if reaction.emoji in welcome_emoji_list and user != client.user and reaction.message.embeds[0].footer.text == welcome_footer:
            server_id = 440632686185414677
            server = client.get_guild(server_id)
            member = server.get_member(user.id)

            if reaction.emoji == '🍞':
                role = get(server.roles, id=485086088017215500)
                await member.add_roles(role)
            elif reaction.emoji == '😂':
                role = get(server.roles, id=448690298760200195)
                await member.add_roles(role)
            elif reaction.emoji == '🥒':
                role = get(server.roles, id=583842403341828115)
                await member.add_roles(role)
            elif reaction.emoji == '🥔':
                role = get(server.roles, id=583842320575889423)
                await member.add_roles(role)
            elif reaction.emoji == '🔴':
                role = get(server.roles, id=464903715854483487)
                await member.add_roles(role)


@client.event
async def on_command_error(ctx, error):
    if ctx.message.content.startswith("$secret"):
        try:
            context = ctx.message.content.split(" ")
            # $secret
            if context[0].lower() != "$secret":
                await ctx.message.author.send("Incorrect message format. Use: $secret <mammal> <channel> <message>")
            # mammal | channel
            if not context[1].isalpha() and not context[2].isalpha():
                await ctx.message.author.send("Incorrect message format. Use: $secret <mammal> <channel> <message>")
            # channel must be "war" or "scott"
            if context[2].lower() != "war" and context[2].lower() != "scott":
                await ctx.message.author.send("Incorrect message format. Use: $secret <mammal> <channel> <message>")

            f = open('mammals.json', 'r')
            temp_json = f.read()
            mammals = json.loads(temp_json)
            f.close()

            checkID = hashlib.md5(str(ctx.message.author.id).encode())
            channel = int()

            if context[2].lower() == "war":
                channel = client.get_channel(525519594417291284)
            elif context[2].lower() == "scott":
                channel = client.get_channel(507520543096832001)
            elif context[2].lower() == "spam":
                channel = client.get_channel(595705205069185047)
            else:
                await ctx.message.author.send("Incorrect message format. Use: $secret <mammal> <channel> <message>")

            if checkID.hexdigest() == mammals[context[1]]:
                context_commands = "{} {} {}".format(context[0], context[1], context[2])
                message = ctx.message.content[len(context_commands):]

                embed = discord.Embed(title="Secret Mammal Messaging System (SMMS)", color=0xFF0000)
                embed.add_field(name="Message", value=message)
                embed.set_thumbnail(url="https://i.imgur.com/EGC1qNt.jpg")

                await channel.send(embed=embed)
            else:
                await ctx.message.author.send("Shit didn't add up")
        except:
            print("An error occured: {}".format(error))
            output_msg = "Whoa there, {}! Something went doesn't look quite right. Please review `$help` for further assistance. Contact my creators if the problem continues.\n" \
                         "```Message ID: {}\n" \
                         "Channel: {} / {}\n" \
                         "Author: {}\n" \
                         "Content: {}\n" \
                         "Error: {}```".format(ctx.message.author.mention, ctx.message.id, ctx.message.channel.name, ctx.message.channel.id, ctx.message.author, ctx.message.content, error)
            await ctx.send(output_msg)
    else:
        err = getattr(error, "original", error)
        print("!!! Error occurred\n!!!! {}\n!!! ".format(error))

        if isinstance(err, commands.CommandNotFound):
            return
        elif isinstance(err, commands.BadArgument):
            return await ctx.send("Command `${}` received a bad argument. Review `$help {}` for more information.".format(ctx.command.qualified_name, ctx.command.qualified_name))
        elif isinstance(err, discord.ext.commands.CommandOnCooldown):
            err = str(error).split(".")
            return await ctx.send("HOLD UP {}!  ${} is on cooldown. {} seconds.".format(ctx.message.author.mention, ctx.command.qualified_name, err[1]))
        elif isinstance(err, discord.ext.commands.MissingAnyRole):
            return await ctx.send("{}! You are not authorized to use this command!".format(ctx.message.author.mention))
        elif isinstance(err, discord.ext.commands.MissingRole):
            return await ctx.send("{}! You are not authorized to use this command!".format(ctx.message.author.mention))
        else:
            output_msg = "Whoa there, {}! Something went doesn't look quite right. Please review `$help` for further assistance. Contact my creators if the problem continues.\n" \
                         "```Message ID: {}\n" \
                         "Channel: {} / {}\n" \
                         "Author: {}\n" \
                         "Content: {}\n" \
                         "Error: {}```".format(ctx.message.author.mention, ctx.message.id, ctx.message.channel.name, ctx.message.channel.id, ctx.message.author, ctx.message.content, error)
            await ctx.send(output_msg)


@client.command(aliases=["quit", "q"])
@commands.has_any_role(606301197426753536, 440639061191950336)
async def huskerbotquit(ctx):
    """ Did HuskerBot act up? Use this only in emergencies. """
    await ctx.send("You are authorized to turn me off. Good bye cruel world 😭.")
    print("!!! I was turned off by '{}' in '{}'.".format(ctx.author, ctx.channel))
    await client.logout()


@client.group(hidden=True)
@commands.has_any_role(606301197426753536, 440639061191950336)
async def purge(ctx):
    """ Delete Husker Bot's previous messages. """
    if ctx.message.channel.id == 458474143403212801:  # prevent from deleting #botlogs
        return

    if ctx.subcommand_passed:
        return

    channel = client.get_channel(ctx.message.channel.id)
    deleteCounter = 0
    missedCounter = 0

    async for message in channel.history(limit=1000, before=None, after=None, around=None, oldest_first=False):  # For whatever reason, the limit=N doesn't actually go back to what I put it
        if message.author == client.user:
            await message.delete()
            deleteCounter += 1
        else:
            missedCounter += 1
            if missedCounter > 25:
                break  # Stop searching forever
        if deleteCounter > 50:
            break  # stop looking through messages


@purge.command(aliases=["b",])
async def bot(ctx):
    authedChanIDs = (622581511488667699, 595705205069185047, 487431877792104470)
    channel = client.get_channel(ctx.message.channel.id)

    if channel.id in authedChanIDs:  # Only authorized use within betting channel or spam testing chan
        msgs = []
        try:
            maxage = datetime.datetime.now() - datetime.timedelta(days=13, hours=23, minutes=59)
            async for message in channel.history(limit=100):
                if message.created_at >= maxage and message.author.bot:
                    msgs.append(message)
            await channel.delete_messages(msgs)
            print("Bulk delete of {} messages successful.".format(len(msgs)))
        except discord.ClientException:
            print("Cannot delete more than 100 messages at a time.")
        except discord.Forbidden:
            print("Missing permissions.")
        except discord.HTTPException:
            print("Deleting messages failed. Bulk messages possibly include messages over 14 days old.")


@purge.command(aliases=["a",])
async def all(ctx):
    authedChanIDs = (622581511488667699, 595705205069185047)
    channel = client.get_channel(ctx.message.channel.id)

    if channel.id in authedChanIDs:  # Only authorized use within betting channel or spam testing chan
        msgs = []
        try:
            maxage = datetime.datetime.now() - datetime.timedelta(days=13, hours=23, minutes=59)
            async for message in channel.history(limit=100):
                if message.created_at >= maxage:
                    msgs.append(message)
            await channel.delete_messages(msgs)
            print("Bulk delete of {} messages successful.".format(len(msgs)))
        except discord.ClientException:
            print("Cannot delete more than 100 messages at a time.")
        except discord.Forbidden:
            print("Missing permissions.")
        except discord.HTTPException:
            print("Deleting messages failed. Bulk messages possibly include messages over 14 days old.")


@purge.command(aliases=["l",])
async def last(ctx):
    channel = client.get_channel(ctx.message.channel.id)

    async for message in channel.history(limit=3, oldest_first=False):
        await message.delete()


async def updateChan(chan: discord.TextChannel, name: str, gameday: bool, reason="Game day mode activation/deactivation"):
    try:
        await chan.set_permissions(client.user, send_messages=True, read_messages=True, manage_channels=True)
        await chan.edit(name=name, reason=reason)
        print("Renamed channel to [{}]. Set {} permissions to {}.".format(name, client.user, gameday))
        print("Sleeping 1 second...")
        time.sleep(1)
    except discord.Forbidden as e:
        print("Forbidden! Channel: {}\n{}".format(chan, e))
    except discord.HTTPException as e:
        print("Editing failed\n{}".format(e))
    except Exception as e:
        print("Unknown error!\n{}".format(e))


@client.group(hidden=True)
@commands.has_any_role(606301197426753536, 440639061191950336, 443805741111836693)
async def gameday(ctx):
    """ Turn on or off game day mode for the bot. """
    pass


@gameday.command()
async def on(ctx):
    edit_msg = await ctx.send("Setting up...")
    for channel in ctx.guild.channels:
        if channel.id == 440868279150444544:
            await updateChan(chan=channel, name="game-chat", gameday=True)
        elif channel.id == 507520543096832001:
            await updateChan(chan=channel, name="delayed-game-chat", gameday=True)

        if channel.id == 440868279150444544:
            await channel.set_permissions(client.user, send_messages=True, read_messages=True, manage_channels=False)
        elif channel.id == 507520543096832001:
            await channel.set_permissions(client.user, send_messages=True, read_messages=True, manage_channels=False)
    await edit_msg.edit(content="Game day mode on!")


@gameday.command()
async def off(ctx):
    edit_msg = await ctx.send("Setting up...")
    for channel in ctx.guild.channels:
        if channel.id == 440868279150444544:
            await updateChan(chan=channel, name="huskerchat", gameday=False)
        elif channel.id == 507520543096832001:
            await updateChan(chan=channel, name="💯🌽👊scotts-tots", gameday=False)

        if channel.id == 440868279150444544:
            await channel.set_permissions(client.user, send_messages=False, read_messages=False, manage_channels=False)
        elif channel.id == 507520543096832001:
            await channel.set_permissions(client.user, send_messages=True, read_messages=True, manage_channels=False)
    await edit_msg.edit(content="Game day mode off!")


@client.command()
async def about(ctx):
    embed = discord.Embed(title="HuskerBot's CV", author=client.user, color=0xFF0000)
    discord.Embed()
    embed.set_thumbnail(url="https://i.imgur.com/Ah3x5NA.png")
    embed.add_field(name="About HuskerBot", value="HuskerBot was created by [/u/refekt](https://reddit.com/u/refekt) and "
                                                  "[/u/psyspoop](https://reddit.com/u/psyspoop). Jeyrad and ModestBeaver assist greatly with coding. "
                                                  "Source code is located on "
                                                  "[GitHub](https://www.github.com/refekt/Husker-Bot).")
    embed.add_field(name="Hosting Location", value="Jeyrad's VPS Server. Thank you!")
    embed.add_field(name="Ready Status", value=client.is_ready())
    embed.add_field(name="Current Latency", value="{:.2f} ms".format(config.bot_latency()))
    embed.add_field(name="Client User", value=client.user)
    embed.add_field(name="Ready Status", value=client.is_ready())
    await ctx.send(embed=embed)


if len(sys.argv) > 0:
    if sys.argv[1] == 'test':
        print("*** Running development server ***")
        client.run(config.TEST_TOKEN)
    elif sys.argv[1] == 'prod':
        print("*** Running production server ***")
        client.run(config.DISCORD_TOKEN)
    else:
        print("You are error. Good bye!")
else:
    print("No arguments presented!")
